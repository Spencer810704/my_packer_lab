pipeline {
    agent any

    options {
        ansiColor('xterm')
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
    }

    parameters {
        // ğŸ¯ å¿…è¦åƒæ•¸
        string(
            name: 'AMI_ID',
            defaultValue: '',
            description: 'è¦åˆªé™¤çš„ AMI ID (å¿…å¡«)'
        )

        string(
            name: 'AMI_NAME',
            defaultValue: '',
            description: 'AMI åç¨± (ç”¨æ–¼æ—¥èªŒè¨˜éŒ„)'
        )

        choice(
            name: 'AWS_REGION',
            choices: ['ap-northeast-1', 'ap-southeast-1', 'us-east-1', 'us-west-2'],
            description: 'AMI æ‰€åœ¨çš„ AWS å€åŸŸ'
        )

        // ğŸ”’ å®‰å…¨åƒæ•¸
        booleanParam(
            name: 'FORCE_DELETE',
            defaultValue: false,
            description: 'å¼·åˆ¶åˆªé™¤ (å³ä½¿æœ‰é—œè¯çš„å¿«ç…§æˆ–å¯¦ä¾‹)'
        )

        booleanParam(
            name: 'DELETE_SNAPSHOTS',
            defaultValue: true,
            description: 'åŒæ™‚åˆªé™¤é—œè¯çš„ EBS å¿«ç…§'
        )

        // ğŸ“‹ å…ƒè³‡æ–™åƒæ•¸
        string(
            name: 'REQUESTER',
            defaultValue: '',
            description: 'åˆªé™¤è«‹æ±‚è€…'
        )

        string(
            name: 'REASON',
            defaultValue: '',
            description: 'åˆªé™¤åŸå› '
        )

        // âš™ï¸ æ§åˆ¶åƒæ•¸
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: true,
            description: 'åƒ…æ¨¡æ“¬åˆªé™¤ï¼Œä¸å¯¦éš›åŸ·è¡Œ'
        )

        // ğŸ”— å›èª¿åƒæ•¸
        string(
            name: 'CALLBACK_DATA',
            defaultValue: '',
            description: 'å›èª¿æ•¸æ“š (ç”±ç³»çµ±è‡ªå‹•å¡«å…¥)'
        )
    }

    environment {
        AWS_DEFAULT_REGION = "${params.AWS_REGION}"
        CALLBACK_URL = "http://infrastructure-mgmt-svc:8087/api/v1/callback/jenkins/delete"
    }

    stages {
        stage('ğŸ“‹ é©—è­‰åƒæ•¸') {
            steps {
                script {
                    echo "ğŸ” é©—è­‰åˆªé™¤åƒæ•¸"

                    // æª¢æŸ¥å¿…å¡«åƒæ•¸
                    if (!params.AMI_ID?.trim()) {
                        error("âŒ AMI_ID æ˜¯å¿…å¡«åƒæ•¸")
                    }

                    if (!params.AMI_ID.startsWith('ami-')) {
                        error("âŒ ç„¡æ•ˆçš„ AMI ID æ ¼å¼: ${params.AMI_ID}")
                    }

                    // é¡¯ç¤ºåˆªé™¤è³‡è¨Š
                    echo """
                    ğŸ“ åˆªé™¤è³‡è¨Š:
                      â€¢ AMI ID: ${params.AMI_ID}
                      â€¢ AMI åç¨±: ${params.AMI_NAME ?: 'N/A'}
                      â€¢ å€åŸŸ: ${params.AWS_REGION}
                      â€¢ è«‹æ±‚è€…: ${params.REQUESTER ?: 'Manual'}
                      â€¢ åŸå› : ${params.REASON ?: 'No reason provided'}
                      â€¢ å¼·åˆ¶åˆªé™¤: ${params.FORCE_DELETE}
                      â€¢ åˆªé™¤å¿«ç…§: ${params.DELETE_SNAPSHOTS}
                      â€¢ DRY_RUN: ${params.DRY_RUN}
                    """
                }
            }
        }

        stage('ğŸ” æª¢æŸ¥ AMI ç‹€æ…‹') {
            steps {
                script {
                    echo "ğŸ“Š æª¢æŸ¥ AMI ç•¶å‰ç‹€æ…‹"
                    
                    try {
                        // ç²å– AMI è©³ç´°è³‡è¨Š
                        def amiInfo = sh(
                            script: """
                                aws ec2 describe-images \\
                                    --image-ids ${params.AMI_ID} \\
                                    --region ${params.AWS_REGION} \\
                                    --output json
                            """,
                            returnStdout: true
                        ).trim()
                        
                        def amiData = readJSON text: amiInfo
                        
                        if (amiData.Images.size() == 0) {
                            error("âŒ æ‰¾ä¸åˆ° AMI: ${params.AMI_ID}")
                        }
                        
                        def ami = amiData.Images[0]
                        env.AMI_STATE = ami.State
                        env.AMI_NAME_ACTUAL = ami.Name ?: 'Unnamed'
                        env.AMI_DESCRIPTION = ami.Description ?: 'No description'
                        
                        echo """
                        ğŸ“‹ AMI è³‡è¨Š:
                          â€¢ åç¨±: ${env.AMI_NAME_ACTUAL}
                          â€¢ ç‹€æ…‹: ${env.AMI_STATE}
                          â€¢ æè¿°: ${env.AMI_DESCRIPTION}
                          â€¢ å‰µå»ºæ™‚é–“: ${ami.CreationDate}
                        """
                        
                        // å„²å­˜å¿«ç…§ IDs
                        def snapshotIds = []
                        ami.BlockDeviceMappings.each { mapping ->
                            if (mapping.Ebs?.SnapshotId) {
                                snapshotIds.add(mapping.Ebs.SnapshotId)
                            }
                        }
                        env.SNAPSHOT_IDS = snapshotIds.join(',')
                        
                        if (snapshotIds.size() > 0) {
                            echo "ğŸ’¾ é—œè¯å¿«ç…§: ${snapshotIds.join(', ')}"
                        }
                        
                    } catch (Exception e) {
                        error("âŒ ç„¡æ³•ç²å– AMI è³‡è¨Š: ${e.message}")
                    }
                }
            }
        }

        stage('ğŸ”’ å®‰å…¨æª¢æŸ¥') {
            when {
                expression { !params.FORCE_DELETE }
            }
            steps {
                script {
                    echo "ğŸ›¡ï¸ åŸ·è¡Œå®‰å…¨æª¢æŸ¥"
                    
                    // æª¢æŸ¥æ˜¯å¦æœ‰æ­£åœ¨ä½¿ç”¨çš„å¯¦ä¾‹
                    def instanceCheck = sh(
                        script: """
                            aws ec2 describe-instances \\
                                --filters "Name=image-id,Values=${params.AMI_ID}" \\
                                          "Name=instance-state-name,Values=pending,running,stopping,stopped" \\
                                --region ${params.AWS_REGION} \\
                                --query 'Reservations[*].Instances[*].InstanceId' \\
                                --output json
                        """,
                        returnStdout: true
                    ).trim()
                    
                    def instances = readJSON text: instanceCheck
                    def instanceList = instances.flatten()
                    
                    if (instanceList.size() > 0) {
                        error("""
                        âŒ æ­¤ AMI ä»æœ‰ ${instanceList.size()} å€‹å¯¦ä¾‹åœ¨ä½¿ç”¨:
                        ${instanceList.join(', ')}
                        è«‹å…ˆçµ‚æ­¢é€™äº›å¯¦ä¾‹ï¼Œæˆ–ä½¿ç”¨ FORCE_DELETE=true å¼·åˆ¶åˆªé™¤
                        """)
                    }
                    
                    echo "âœ… å®‰å…¨æª¢æŸ¥é€šé: æ²’æœ‰æ­£åœ¨ä½¿ç”¨çš„å¯¦ä¾‹"
                }
            }
        }

        stage('ğŸ—‘ï¸ åˆªé™¤ AMI') {
            steps {
                script {
                    if (params.DRY_RUN) {
                        echo "ğŸ§ª DRY_RUN æ¨¡å¼: æ¨¡æ“¬åˆªé™¤ AMI"
                        echo "å°‡åŸ·è¡Œ: aws ec2 deregister-image --image-id ${params.AMI_ID}"
                        env.DELETE_STATUS = "dry_run_success"
                    } else {
                        echo "ğŸ—‘ï¸ é–‹å§‹åˆªé™¤ AMI: ${params.AMI_ID}"
                        
                        try {
                            sh """
                                aws ec2 deregister-image \\
                                    --image-id ${params.AMI_ID} \\
                                    --region ${params.AWS_REGION}
                            """
                            
                            echo "âœ… AMI å·²æˆåŠŸè¨»éŠ·"
                            env.DELETE_STATUS = "success"
                            
                        } catch (Exception e) {
                            env.DELETE_STATUS = "failed"
                            env.DELETE_ERROR = e.message
                            error("âŒ AMI åˆªé™¤å¤±æ•—: ${e.message}")
                        }
                    }
                }
            }
        }

        stage('ğŸ’¾ åˆªé™¤å¿«ç…§') {
            when {
                expression { 
                    params.DELETE_SNAPSHOTS && 
                    env.SNAPSHOT_IDS?.trim() &&
                    env.DELETE_STATUS in ['success', 'dry_run_success']
                }
            }
            steps {
                script {
                    def snapshotIds = env.SNAPSHOT_IDS.split(',')
                    echo "ğŸ’¾ æº–å‚™åˆªé™¤ ${snapshotIds.size()} å€‹å¿«ç…§"
                    
                    def deletedSnapshots = []
                    def failedSnapshots = []
                    
                    snapshotIds.each { snapshotId ->
                        if (params.DRY_RUN) {
                            echo "ğŸ§ª DRY_RUN: å°‡åˆªé™¤å¿«ç…§ ${snapshotId}"
                            deletedSnapshots.add(snapshotId)
                        } else {
                            try {
                                sh """
                                    aws ec2 delete-snapshot \\
                                        --snapshot-id ${snapshotId} \\
                                        --region ${params.AWS_REGION}
                                """
                                deletedSnapshots.add(snapshotId)
                                echo "âœ… å·²åˆªé™¤å¿«ç…§: ${snapshotId}"
                            } catch (Exception e) {
                                failedSnapshots.add(snapshotId)
                                echo "âš ï¸ ç„¡æ³•åˆªé™¤å¿«ç…§ ${snapshotId}: ${e.message}"
                            }
                        }
                    }
                    
                    env.DELETED_SNAPSHOTS = deletedSnapshots.join(',')
                    env.FAILED_SNAPSHOTS = failedSnapshots.join(',')
                    
                    if (failedSnapshots.size() > 0) {
                        echo "âš ï¸ ${failedSnapshots.size()} å€‹å¿«ç…§åˆªé™¤å¤±æ•—"
                    }
                }
            }
        }

        stage('ğŸ“ è¨˜éŒ„å¯©è¨ˆæ—¥èªŒ') {
            steps {
                script {
                    def auditLog = [
                        timestamp: new Date().format('yyyy-MM-dd HH:mm:ss'),
                        action: 'DELETE_AMI',
                        ami_id: params.AMI_ID,
                        ami_name: env.AMI_NAME_ACTUAL ?: params.AMI_NAME,
                        region: params.AWS_REGION,
                        requester: params.REQUESTER ?: 'Manual',
                        reason: params.REASON ?: 'No reason provided',
                        dry_run: params.DRY_RUN,
                        force_delete: params.FORCE_DELETE,
                        delete_snapshots: params.DELETE_SNAPSHOTS,
                        deleted_snapshots: env.DELETED_SNAPSHOTS ?: '',
                        failed_snapshots: env.FAILED_SNAPSHOTS ?: '',
                        status: env.DELETE_STATUS,
                        build_number: env.BUILD_NUMBER,
                        build_url: env.BUILD_URL
                    ]
                    
                    def auditJson = groovy.json.JsonOutput.prettyPrint(
                        groovy.json.JsonOutput.toJson(auditLog)
                    )
                    
                    echo "ğŸ“ å¯©è¨ˆæ—¥èªŒ:\n${auditJson}"
                }
            }
        }
    }

    post {
        always {
            script {
                echo "ğŸ“¡ ç™¼é€åˆªé™¤çµæœå›èª¿"
                
                // æº–å‚™å›èª¿æ•¸æ“š
                def callbackData = [
                    build_id: env.BUILD_NUMBER as Integer,
                    action: 'delete_ami',
                    ami_id: params.AMI_ID,
                    ami_name: env.AMI_NAME_ACTUAL ?: params.AMI_NAME,
                    status: determineDeleteStatus(),
                    dry_run: params.DRY_RUN,
                    deleted_snapshots: env.DELETED_SNAPSHOTS?.split(',') ?: [],
                    failed_snapshots: env.FAILED_SNAPSHOTS?.split(',') ?: [],
                    log_url: "${env.BUILD_URL}console",
                    callback_data: [:]
                ]
                
                // è§£æåŸå§‹å›èª¿æ•¸æ“š
                if (params.CALLBACK_DATA?.trim()) {
                    try {
                        def originalCallbackData = readJSON text: params.CALLBACK_DATA
                        callbackData.callback_data = originalCallbackData
                        echo "âœ… å·²è§£æå›èª¿æ•¸æ“š"
                    } catch (Exception e) {
                        echo "âš ï¸ ç„¡æ³•è§£æ CALLBACK_DATA: ${e.message}"
                    }
                }
                
                def callbackJson = groovy.json.JsonOutput.toJson(callbackData)
                
                try {
                    writeFile file: 'callback_payload.json', text: callbackJson
                    
                    def curlResult = sh(
                        script: """
                            curl -s -w "HTTPSTATUS:%{http_code}" \\
                                 -X POST \\
                                 -H "Content-Type: application/json" \\
                                 -d @callback_payload.json \\
                                 --connect-timeout 10 \\
                                 --max-time 30 \\
                                 "${env.CALLBACK_URL}"
                        """,
                        returnStdout: true
                    ).trim()
                    
                    sh 'rm -f callback_payload.json'
                    
                    def httpStatus = curlResult.tokenize("HTTPSTATUS:")[1]
                    def responseBody = curlResult.tokenize("HTTPSTATUS:")[0]
                    
                    if (httpStatus.startsWith('2')) {
                        echo "âœ… å›èª¿ç™¼é€æˆåŠŸ: HTTP ${httpStatus}"
                    } else {
                        echo "âš ï¸ å›èª¿è¿”å›éæˆåŠŸç‹€æ…‹: HTTP ${httpStatus}"
                        echo "éŸ¿æ‡‰å…§å®¹: ${responseBody}"
                    }
                    
                } catch (Exception e) {
                    echo "âŒ å›èª¿ç™¼é€å¤±æ•—: ${e.message}"
                    sh 'rm -f callback_payload.json || true'
                }
                
                echo "ğŸ§¹ æ¸…ç†å·¥ä½œç©ºé–“"
                cleanWs()
            }
        }

        success {
            script {
                def message = params.DRY_RUN ? 
                    "âœ… AMI åˆªé™¤æ¨¡æ“¬æˆåŠŸå®Œæˆ" : 
                    "âœ… AMI å·²æˆåŠŸåˆªé™¤"
                    
                echo """
                ${message}
                  â€¢ AMI ID: ${params.AMI_ID}
                  â€¢ åç¨±: ${env.AMI_NAME_ACTUAL ?: params.AMI_NAME}
                  â€¢ è«‹æ±‚è€…: ${params.REQUESTER ?: 'Manual'}
                """
                
                if (env.DELETED_SNAPSHOTS?.trim()) {
                    echo "  â€¢ å·²åˆªé™¤å¿«ç…§: ${env.DELETED_SNAPSHOTS}"
                }
            }
        }

        failure {
            script {
                echo """
                âŒ AMI åˆªé™¤å¤±æ•—
                  â€¢ AMI ID: ${params.AMI_ID}
                  â€¢ éŒ¯èª¤: ${env.DELETE_ERROR ?: 'Unknown error'}
                """
            }
        }
    }
}

def determineDeleteStatus() {
    if (params.DRY_RUN) {
        return "dry_run"
    }
    
    if (env.DELETE_STATUS == 'success') {
        if (env.FAILED_SNAPSHOTS?.trim()) {
            return "partial_success"
        }
        return "success"
    }
    
    return "failed"
}